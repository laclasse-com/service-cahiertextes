# Array wraps a javascript array.
#
# @todo No proper support for handling recursive arrays. (e.g. a = [], a.push(a)).
#   Look for ArraySpecs.recursive_array in the specs.
#
# @todo The methods #taint, #trust, #freeze do nothing
#
# @method #equals(other)
#   Alias for {#==}  - Two arrays are equal if they contain the same number of elements
#   and if each element is equal to (according to {R.Object#==}) the corresponding
#   element in the other array.
#   @example
#      R(["a", "c"]   ).equals(["a", "c", 7])     #=> false
#      R(["a", "c", 7]).equals(["a", "c", 7])     #=> true
#      R(["a", "c", 7]).equals(["a", "d", "f"])   #=> false
#      # #equals is an alias to #==
#      R(["a", "c"]   ).equals(["a", "c", 7])     #=> false
#   @return [Boolean]
#   @alias #==
#
# @method #append(obj)
#   Alias for {#<<} - Pushes the given object on to the end of this array. This
#   expression returns the array itself, so several appends may be chained
#   together.
#   @example
#      R([ 1, 2 ]).append("c").append("d").append([3, 4])
#      #=> [ 1, 2, "c", "d", [ 3, 4 ] ]
#   @param [Object] obj
#   @return [R.Array]
#
# @method #intersection(other)
#   Alias for {#&} - Returns a new array containing elements common to the two
#   arrays, with no duplicates.
#   @example
#     R([ 1, 1, 3, 5 ]).intersection [ 1, 2, 3 ]
#     #=> [ 1, 3 ]
#   @alias #&
#   @param [Array] other
#   @return [R.Array]
#   @todo Slow implementation, slight deviation Ruby implementation of equality check
#
# @method #cmp(other)
#   Alias for {#cmp} - Returns an integer (-1, 0, or +1) if this array is less than,
#   equal to, or greater than other_ary. Each object in each array is compared
#   (using <=>). If any value isn’t equal, then that inequality is the return
#   value. If all the values found are equal, then the return is based on a
#   comparison of the array lengths. Thus, two arrays are “equal” according to
#   {R.Array#cmp} if and only if they have the same length and the value of each
#   element is equal to the value of the corresponding element in the other
#   array.
#   @example
#     R([ "a", "a", "c" ]   ).cmp [ "a", "b", "c" ]   #=> -1
#     R([ 1, 2, 3, 4, 5, 6 ]).cmp [ 1, 2 ]            #=> +1
#   @param [Array] other
#   @return [R.Array]
#
class RubyJS.Array extends RubyJS.Object
  @include R.Enumerable

  # ---- RubyJSism ------------------------------------------------------------

  # @private
  is_array: -> true

  # @private
  iterator: () ->
    @__native__


  # ---- Constructors & Typecast ----------------------------------------------

  # Creates a new R.Array with a clone of the given array.
  #
  constructor: (@__native__ = [], recursive ) ->
    if recursive is true
      idx = -1
      len = @__native__.length
      while ++idx < len
        @__native__[idx] = R(@__native__[idx], recursive)

  # Returns a new array. In the first form, the new array is empty. In the
  # second it is created with size copies of obj (that is, size references to
  # the same obj). The third form creates a copy of the array passed as a
  # parameter (the array is generated by calling #to_ary on the parameter). In
  # the last form, an array of the given size is created. Each element in this
  # array is calculated by passing the element’s index to the given block and
  # storing the return value.
  #
  # @example
  #     R.Array.new()                  # => []
  #     R.Array.new(2)                 # => [null, null]
  #     R.Array.new(3, "A")            # => ['A','A','A']
  #     # only one copy of the object is created
  #     a = R.Array.new(2, R('a') )   # => ['a', 'a']
  #     a[0].capitalize_bang()
  #     a                             # => ['A', 'A']
  #     # here multiple copies are created
  #     a = R.Array.new(2, -> R('a'))
  #     squares = R.Array.new(5, (i) -> i.multiply(i)
  #     copy = R.Array.new(squares)
  #
  @new: (args...) ->
    block = __extract_block(args)
    throw R.ArgumentError.new() if args.length >= 3
    size = args[0]
    obj  = args[1]

    return new R.Array([])  if size is undefined
    throw R.TypeError.new() if obj isnt undefined && (@isNativeArray(size) || size.is_array?)

    return new R.Array(size) if @isNativeArray(size)
    return size.to_ary()     if size.to_ary? && obj is undefined

    size = RCoerce.to_int_native(size)
    throw R.ArgumentError.new() if size < 0
    obj = null if obj is undefined

    ary = []
    idx = -1
    while ++idx < size
      ary[idx] = if block then block(idx) else obj
    return new R.Array(ary)

  # @private
  @typecast: (arr, recursive) ->
    new R.Array(arr, recursive)

  # @private
  @isNativeArray: nativeArray.isArray or (obj) ->
    nativeToString.call(obj) is '[object Array]'


  # Try to convert obj into an array, using to_ary method. Returns converted
  # array or nil if obj cannot be converted for any reason. This method can be
  # used to check if an argument is an array.
  #
  # @example
  #     R.Array.try_convert([1])      # => [1]
  #     R.Array.try_convert(R([1]))   # => [1]
  #     R.Array.try_convert("1")      # => null
  #
  # @todo Does currently not check if value from to_ary() is an Array
  #
  @try_convert: (obj) ->
    return obj          if obj.is_array?
    return @new(obj)    if @isNativeArray(obj)

    if obj.to_ary?
      # the correct behaviour currently breaks some tests.
      obj.to_ary() #.tap (a) -> throw R.TypeError.new() if a.is_array?
    else
      null

  # ---- Javascript primitives --------------------------------------------------

  # Returns native array.
  #
  # @return Array
  valueOf: (recursive) ->
    if recursive
      @to_native(true)
    else
      @__native__


  # Returns native array.
  #
  # @param [boolean] recursive if set to true array and its elements are unboxed
  # @return Array
  #
  to_native: (recursive = false) ->
    if recursive
      # explicitly coded for performance reasons
      [idx,len,ary] = @__iter_vars__()
      while (++idx < len)
        el = @__native__[idx]
        el = el.to_native(true) if el && el.to_native?
        ary[idx] = el
      ary
    else
      # Clone array to avoid confusion
      @__native__.slice(0)


  # @private
  unbox: @prototype.to_native


  to_native_clone: -> @__native__.slice(0)


  __iter_vars__: (no_array) ->
    len = @__native__.length
    if no_array
      [-1, len]
    else
      [-1, len, nativeArray(len)]

  # ---- Instance methods -----------------------------------------------------

  equals: (other) ->
    other = R(other)
    unless other.is_array?
      return false unless other.to_ary?
      return other.equals(this)

    _arr.equals(@__native__, other.__native__)


  '<<': (obj) ->
    @__native__.push(obj)
    this


  '&': (other) ->
    new RArray(_arr.intersection(@__native__, other))


  cmp: (other) ->
    _arr.cmp(@__native__, other)


  # Returns the element at index. A negative index counts from the end of
  # self. Returns nil if the index is out of range. See also Array#[].
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.at(0)     #=> "a"
  #     a.at(-1)    #=> "e"
  #
  # @return [Object]
  #
  at: (index) ->
    # UNSUPPORTED: __ensure_args_length(arguments, 1)
    index = RCoerce.to_int_native(index)
    _arr.at(@__native__, index)


  # Removes all elements from self.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.clear()    #=> [ ]
  #
  # @return [R.Array]
  #
  clear: () ->
    __ensure_args_length(arguments, 0)
    @__native__.length = 0
    @replace @__native__
    this


  # @todo does not copy the singleton class of the copied object
  clone: () ->
    @dup()


  # Invokes the block once for each element of self, replacing the element
  # with the value returned by block. See also Enumerable#collect.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.collect_bang (x) -> x+"!"
  #     a
  #     #=>  [ "a!", "b!", "c!", "d!" ]
  #
  # @alias #map_bang
  # @return self
  # @note some edge-cases not handled when breaking out from block.
  #
  collect_bang: (block) ->
    return @to_enum('collect_bang') unless block?.call?
    @replace _arr.collect(@__native__, block)


  # When invoked with a block, yields all combinations of length n of elements
  # from ary and then returns ary itself. The implementation makes no
  # guarantees about the order in which the combinations are yielded.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([1, 2, 3, 4])
  #     a.combination(1).to_a()  #=> [[1],[2],[3],[4]]
  #     a.combination(2).to_a()  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
  #     a.combination(3).to_a()  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
  #     a.combination(4).to_a()  #=> [[1,2,3,4]]
  #     a.combination(0).to_a()  #=> [[]] # one combination of length 0
  #     a.combination(5).to_a()  #=> []   # no combinations of length 5
  #     R([1, 2, 3, 4]).combination(3).to_a()
  #
  # @return R.Array
  #
  combination: (num, block) ->
    return @to_enum('combination', num) unless block?
    _arr.combination(@__native__, num, block)
    this


  # Returns a copy of self with all nil elements removed.
  #
  # @example
  #     R([ "a", nil, "b", nil, "c", nil ]).compact()
  #     #=> [ "a", "b", "c" ]
  #
  # @return [R.Array]
  #
  compact: ->
    new RArray(_arr.compact(@__native__))


  # Removes nil elements from the array. Returns nil if no changes were made,
  # otherwise returns ary.
  #
  # @example
  #
  #     R([ "a", nil, "b", nil, "c" ]).compact_bang()
  #     # => [ "a", "b", "c" ]
  #     R([ "a", "b", "c" ]).compact_bang()
  #     # => null
  #
  # @return self or null if nothing changed
  #
  compact_bang: ->
    len = @__native__.length
    ary = _arr.compact(@__native__)
    @replace ary
    if len == ary.length then null else this


  # Appends the elements of other_ary to self.
  #
  # @example
  #     R([ "a", "b" ]).concat( ["c", "d"] )
  #     #=> [ "a", "b", "c", "d" ]
  #
  # @return R.Array
  #
  concat: (other) ->
    other = RCoerce.to_ary_native(other)
    @replace @__native__.concat(other)


  # Deletes items from self that are equal to obj. If any items are found,
  # returns obj. If the item is not found, returns nil. If the optional code
  # block is given, returns the result of block if the item is not found. (To
  # remove nil elements and get an informative return value, use compact!)
  #
  # @example
  #     a = R([ "a", "b", "b", "b", "c" ])
  #     a.delete("b")                   #=> "b"
  #     a                               #=> ["a", "c"]
  #     a.delete("z")                   #=> nil
  #     a.delete("z", -> 'not found')   #=> "not found"
  #
  delete: (args...) ->
    block   = __extract_block(args)
    _arr.delete(@__native__, args[0], block)


  # Deletes the element at the specified index, returning that element, or nil
  # if the index is out of range. See also Array#slice!.
  #
  # @example
  #    a = R.w('ant bat cat dog')
  #    a.delete_at(2)    #=> "cat"
  #    a                 #=> ["ant", "bat", "dog"]
  #    a.delete_at(99)   #=> null
  #
  # @return obj or null
  #
  delete_at: (idx) ->
    idx = RCoerce.to_int_native(idx)
    _arr.delete_at(@__native__, idx)



  # Deletes every element of self for which block evaluates to true. The array
  # is changed instantly every time the block is called and not after the
  # iteration is over. See also Array#reject!
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.delete_if (x) -> x >= "b"
  #     #=> ["a"]
  #
  # @return [R.Array, R.Enumerator] when no block
  #
  delete_if: (block) ->
    @replace @reject(block)


  dup: () -> new RubyJS.Array(@__native__.slice(0))


  # @todo should not call #to_ary on its argument, but it does through boxing, Array.try_convert
  eql: (other) ->
    return true if @equals(other)
    other = R(other)
    return false unless other.is_array?
    return false unless @size().equals other.size()

    # TODO: no nested loop detection
    other_arr = other.to_native()
    @catch_break (breaker) ->
      i = 0
      @each (x) ->
        breaker.break(false) unless R(x).eql(other_arr[i])
        i += 1
      true


  # Same as Array#each, but passes the index of the element instead of the
  # element itself.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.each_index (x) -> R.puts "#{x} -- "
  #     # out: 0 -- 1 -- 2 --
  #
  each_index: (block) ->
    return @to_enum('each_index') unless block?
    _arr.each_index(@__native__, block)
    this



  # Calls block once for each element in self, passing that element as a
  # parameter.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.each (x) -> R.puts "#{x} -- "
  #     # out: a -- b -- c --
  #
  # @alias #each
  #
  each: (block) ->
    return @to_enum() unless block?.call?
    _arr.each(@__native__, block)
    this


  # Alias for R.Array#[] R.Array#slice
  #
  # Element Reference—Returns the element at index, or returns a subarray
  # starting at start and continuing for length elements, or returns a
  # subarray specified by range. Negative indices count backward from the end
  # of the array (-1 is the last element). Returns nil if the index (or
  # starting index) are out of range.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.get(2) +  a.get(0) + a.get(1)    #=> "cab"
  #     a.get(6)                   #=> nil
  #     a.get(1, 2)                #=> [ "b", "c" ]
  #     a.get(R.rng(1,3))          #=> [ "b", "c", "d" ]
  #     a.get(R.rng(4,7))          #=> [ "e" ]
  #     a.get(R.rng(6,10))         #=> nil
  #     a.get(-3, 3)               #=> [ "c", "d", "e" ]
  #     # special cases
  #     a.get(5)                   #=> nil
  #     a.get(5, 1)                #=> []
  #     a.get(R.rng(5,10))         #=> []
  #
  get: (a, b) ->
    @slice(a,b)


  # TODO: IMPLEMENT remaining arguments!!
  #
  #
  set: (idx, obj) ->
    if idx.is_range?
      return @set$range(idx, obj)
    if arguments.length is 3
      return @set$int$int.apply(this, arguments)

    idx = RCoerce.to_int_native(idx)
    @__native__[idx] = obj

    obj


  # @private
  set$range: (rng, obj) ->
    throw R.NotImplementedError.new()


  # @private
  set$int$int: (start, length, obj) ->
    throw R.NotImplementedError.new()


  # Returns true if self contains no elements.
  #
  #
  empty: () ->
    @__native__.length is 0

  # Tries to return the element at position index. If the index lies outside
  # the array, the first form throws an IndexError exception, the second form
  # returns default, and the third form returns the value of invoking the
  # block, passing in the index. Negative values of index count from the end
  # of the array.
  #
  # @example
  #     a = R([ 11, 22, 33, 44 ])
  #     a.fetch(1)               #=> 22
  #     a.fetch(-1)              #=> 44
  #     a.fetch(4, 'cat')        #=> "cat"
  #     a.fetch(4, (i) -> i*i))  #=> 16
  #
  fetch: (idx, default_or_block) ->
    _arr.fetch(@__native__, idx, default_or_block)


  # Fills array with obj or block.
  #
  #     fill(obj) → ary
  #     fill(obj, start [, length]) → ary
  #     fill(obj, range ) → ary
  #     fill (index) -> block  → ary
  #     fill(start [, length],  (index) -> block  → ary
  #     # not yet implemented:
  #     fill(range, (index) -> block ) → ary
  #
  # The first three forms set the selected elements of self (which may be the
  # entire array) to obj. A start of nil is equivalent to zero. A length of
  # nil is equivalent to self.length. The last three forms fill the array with
  # the value of the block. The block is passed the absolute index of each
  # element to be filled. Negative values of start count from the end of the
  # array.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.fill("x")               #=> ["x", "x", "x", "x"]
  #     a.fill("z", 2, 2)         #=> ["x", "x", "z", "z"]
  #     # a.fill("y", 0..1)         #=> ["y", "y", "z", "z"]
  #     a.fill (i) -> i*i         #=> [0, 1, 4, 9]
  #     a.fill(-2) (i) -> i*i*i   #=> [0, 1, 8, 27]
  #
  # @todo implement fill(range, ...)
  #
  fill: (args...) ->
    throw R.ArgumentError.new() if args.length == 0
    # OPTIMIZE arguments
    block = __extract_block(args)

    if block
      throw R.ArgumentError.new() if args.length >= 3
      _arr.fill(@__native__,  args[0],  args[1], block)
    else
      throw R.ArgumentError.new() if args.length > 3
      _arr.fill(@__native__,  args[0], args[1], args[2])

    this


  # Returns a new array that is a one-dimensional flattening of this array
  # (recursively). That is, for every element that is an array, extract its
  # elements into the new array. If the optional level argument determines the
  # level of recursion to flatten.
  #
  # @example
  #     s = R([ 1, 2, 3 ])           #=> [1, 2, 3]
  #     t = R([ 4, 5, 6, [7, 8] ])   #=> [4, 5, 6, [7, 8]]
  #     a = R([ s, t, 9, 10 ])       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
  #     a.flatten()                  #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a = R([ 1, 2, [3, [4, 5] ] ])
  #     a.flatten(1)                 #=> [1, 2, 3, [4, 5]]
  #
  # TODO: IMPORTANT!
  # @todo fails for [undefined, null]
  # @todo do not typecast elements!
  #
  flatten: (recursion = -1) ->
    new RArray(_arr.flatten(@__native__, recursion))


  # Inserts the given values before the element with the given index (which
  # may be negative).
  #
  # @example
  #     a = R.w('a b c d')
  #     a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]
  #     a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
  #
  insert: (idx) ->
    throw R.ArgumentError.new() if idx is undefined
    return this if arguments.length == 0
    ary = __call(_arr.insert, @__native__, arguments)
    this


  # Creates a string representation of self.
  #
  # Also aliased as: {#to_s}
  #
  # @example
  #     R([1,2]).inspect()     # => '[1, 2]'
  #
  inspect: () ->
    R("[#{@map((e) -> R.inspect(e) ).join(', ')}]")


  # Returns a string created by converting each element of the array to a
  # string, separated by sep.
  #
  # @example
  #     R([ "a", "b", "c"]).join()      # => "abc"
  #     R([ "a", "b", "c"]).join(null)  # => "abc"
  #     R([ "a", "b", "c"]).join("-")   # => "a-b-c"
  #     # joins nested arrays
  #     R([1,[2,[3,4]]]).join('.')      # => '1.2.3.4'
  #     # Default separator R['$,'] (in ruby: $,)
  #     R['$,']                        # => null
  #     R([ "a", "b", "c"]).join()      # => "abc"
  #     R['$,'] = '|'                  # => '|'
  #     R([ "a", "b", "c"]).join()      # => "a|b|c"
  #
  # @todo Does not ducktype via #to_str, #to_ary, #to_s or throw error
  #
  join: (sep) ->
    sep = RCoerce.to_str_native(sep) if sep?
    new RString(_arr.join(@__native__, sep))


  # Deletes every element of self for which block evaluates to false. See also
  # Array#select!
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([1,2,3,4])
  #     a.keep_if (v) -> v <= 3   # => [1,2,3]
  #     a.keep_if  -> true       # => a # returns self if not changed
  #
  keep_if: (block) ->
    return @to_enum('keep_if') unless block?.call?
    ary = _arr.keep_if(@__native__, block)
    if @__native__.length is ary.length then this else @replace(ary)


  # Array Difference - Returns a new array that is a copy of the original
  # array, removing any items that also appear in other_ary. (If you need set-
  # like behavior, see the library class Set.)
  #
  # @note minus checks for identity using other.include(el), which differs slightly
  #   from the reference which uses #hash and #eql?
  #
  # @example
  #     R([ 1, 1, 2, 2, 3, 3, 4, 5 ]) - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]
  #
  # @todo recursive arrays not tested
  #
  minus: (other) ->
    new RArray(_arr.minus(@__native__, other))


  # Repetition—With a String argument, equivalent to self.join(str).
  # Otherwise, returns a new array built by concatenating the int copies of
  # self.
  #
  # @example
  #     R([ 1, 2, 3 ]).multiply 3    # => [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
  #     R([ 1, 2, 3 ]).multiply ","  # => "1,2,3"
  #
  multiply: (multiplier) ->
    __ensure_args_length(arguments, 1)
    # can be string or array
    R(_arr.multiply(@__native__, multiplier))

  # Returns the last element(s) of self. If the array is empty, the first form
  # returns nil.
  #
  # @example
  #     a = R([ "w", "x", "y", "z" ])
  #     a.last()     #=> "z"
  #     a.last(2)    #=> ["y", "z"]
  #
  last: (n) ->
    if @__native__.length < 1
      return null if n is undefined
      return new R.Array([])

    return @at(-1) if n is undefined
    n = RCoerce.to_int_native(n)

    new R.Array( _a.last(@__native__, n) )


  # @private
  # @todo Not yet implemented
  permutation: (args...) ->
    throw R.NotImplementedError.new()
  #   block = __extract_block(args)
  #   num   = args[0]
  #   return @to_enum('permutation', num) unless block?.call?

  #   num = if num is undefined then @size() else RCoerce.to_int(num)

  #   if num.lt(0) || @size().lt num
  #     # no permutations, yield nothing
  #   else if num.equals 0
  #     # exactly one permutation: the zero-length array
  #     block.call(this, new R.Array([]))
  #   else if num.equals 1
  #     # this is a special, easy case
  #     @each (val) -> block.call(this, R([val]))
  #   else
  #     # this is the general case
  #     perm = R.Array.make(num)
  #     used = R.Array.make(@size(), false)

  #     if block
  #       # offensive (both definitions) copy.
  #       offensive = @dup()
  #       offensive.__permute__(num, perm, R(0), used, block)
  #     # else
  #     #   @__permute__(num, perm, R(0), used)

  #   this

  # # @private
  # __permute__: (num, perm, index, used, block) ->
  #   # Recursively compute permutations of r elements of the set [0..n-1].
  #   # When we have a complete permutation of array indexes, copy the values
  #   # at those indexes into a new array and yield that array.
  #   #
  #   # num: the number of elements in each permutation
  #   # p: the array (of size num) that we're filling in
  #   # index: what index we're filling in now
  #   # used: an array of booleans: whether a given index is already used
  #   #
  #   # Note: not as efficient as could be for big num.
  #   self = this
  #   @size().times (i) ->
  #     unless used[i]
  #       perm[index] = i
  #       if index.lt(num.minus 1)
  #         used[i] = true
  #         self.__permute__(num, perm, index.plus(1), used, block)
  #         used[i] = false
  #       else
  #         block.apply(this, self.values_at(perm...)...)


  # Concatenation—Returns a new array built by concatenating the two arrays
  # together to produce a third array.
  #
  # @example
  #     R([ 1, 2, 3 ]).plus [ 3, 4 ]     #=> [ 1, 2, 3, 3, 4 ]
  #     R([ 1, 2, 3 ]).plus([ 3, 4 ])    #=> [ 1, 2, 3, 3, 4 ]
  #
  # @note recursive arrays untested.
  #
  plus: (other) ->
    @concat(other)


  # Removes the last element from self and returns it, or nil if the array is empty.
  #
  # If a number n is given, returns an array of the last n elements (or less)
  # just like array.slice!(-n, n) does.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.pop()     # => "d"
  #     a.pop(2)    # => ["b", "c"]
  #     a           # => ["a"]
  #
  # @todo check for recursive arrays
  #
  pop: (many) ->
    throw R.ArgumentError.new() if arguments.length > 1

    if many is undefined
      _arr.pop(@__native__)
    else
      new RArray(_arr.pop(@__native__, many))

  # Returns an array of all combinations of elements from all arrays. The
  # length of the returned array is the product of the length of self and the
  # argument arrays. If given a block, product will yield all combinations and
  # return self instead.
  #
  # @example
  #     R( [1,2,3] ).product([4,5])       #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
  #     R( [1,2]   ).product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]
  #     R( [1,2]   ).product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
  #                                       #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
  #     R( [1,2] ).product()              #=> [[1],[2]]
  #     R( [1,2] ).product([])            #=> []
  #
  # @todo does not check if the result size will fit in an Array.
  #
  product: ->
    ary = __call(_arr.product, @__native__, arguments)
    if ary == @__native__ then this else new RArray(ary)


  # Append—Pushes the given object(s) on to the end of this array. This
  # expression returns the array itself, so several appends may be chained
  # together.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.push("d", "e", "f")
  #     #=> ["a", "b", "c", "d", "e", "f"]
  #
  push: ->
    __call(_arr.push, @__native__, arguments)
    this


  # Searches through the array whose elements are also arrays. Compares obj
  # with the second element of each contained array using ==. Returns the
  # first contained array that matches. See also Array#assoc.
  #
  # @example
  #     a = R([ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ])
  #     a.rassoc("two")    #=> [2, "two"]
  #     a.rassoc("four")   #=> nil
  #
  rassoc: (obj) ->
    _arr.rassoc(@__native__, obj)


  # Returns the index of the last object in self == to obj. If a block is
  # given instead of an argument, returns index of first object for which
  # block is true, starting from the last object. Returns nil if no match is
  # found. See also Array#index.
  #
  # If neither block nor argument is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "b", "b", "c" ])
  #     a.rindex("b")             # => 3
  #     a.rindex("z")             # => nil
  #     a.rindex (x) -> x == "b"  # => 3
  #
  # @note does not check if array has changed.
  #
  rindex: (other) ->
    return @to_enum('rindex') if other is undefined
    ridx = _arr.rindex(@__native__, other)
    if ridx is null then null else new R.Fixnum(ridx)

  # Choose a random element or n random elements from the array. The elements
  # are chosen by using random and unique indices into the array in order to
  # ensure that an element doesn’t repeat itself unless the array already
  # contained duplicate elements. If the array is empty the first form returns
  # nil and the second form returns an empty array.
  #
  # If rng is given, it will be used as the random number generator.
  #
  #     R([1,2,3]).sample()    # => 2
  #     R([1,2,3]).sample(2)   # => [3,1]
  #     R([1,2,3]).sample(4)   # => [2,1,3]
  #
  sample: (n, range = undefined) ->
    val = _arr.sample(@__native__, n, range)
    if n is undefined
      val
    else
      new RArray(val)


  # Equivalent to Array#delete_if, deleting elements from self for which the
  # block evaluates to true, but returns nil if no changes were made. The array
  # is changed instantly every time the block is called and not after the
  # iteration is over. See also Enumerable#reject and Array#delete_if.
  #
  # If no block is given, an enumerator is returned instead.
  #
  reject_bang: (block) ->
    return @to_enum('reject_bang') unless block?.call?
    ary = @reject(block)
    if ary.__size__() is @__size__() then null else @replace(ary)


  # Replaces the contents of self with the contents of other_ary, truncating
  # or expanding if necessary.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.replace([ "x", "y", "z" ])   # => ["x", "y", "z"]
  #     a                              # => ["x", "y", "z"]
  #     a.replace(R([1]))             # => [1]
  #
  replace: (val) ->
    __ensure_args_length(arguments, 1)
    # TODO: Use RCoerce.to_ary_native
    @__native__ = if val.to_ary? then val.to_ary().to_native().slice(0) else val.slice(0)
    this


  # Returns a new array containing self‘s elements in reverse order.
  #
  #     R([ "a", "b", "c" ]).reverse()   #=> ["c", "b", "a"]
  #     R([ 1 ]).reverse()               #=> [1]
  #
  reverse: () ->
    @dup().tap (w) -> w.reverse_bang()


  # Reverses self in place.
  #
  #     a = R([ "a", "b", "c" ])
  #     a.reverse_bang()   #=> ["c", "b", "a"]
  #     a                  #=> ["c", "b", "a"]
  #
  reverse_bang: () ->
    @replace @__native__.reverse()
    this

  # Same as Array#each, but traverses self in reverse order.
  #
  #     a = R([ "a", "b", "c" ])
  #     a.reverse_each (x) -> R.puts "#{x} "
  #     # out: c b a
  #
  reverse_each: (block) ->
    return @to_enum('reverse_each') unless block && block.call?
    _arr.reverse_each(@__native__, block)
    this


  # Returns new array by rotating self so that the element at cnt in self is
  # the first element of the new array. If cnt is negative then it rotates in
  # the opposite direction.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.rotate()       # => ["b", "c", "d", "a"]
  #     a                # => ["a", "b", "c", "d"]
  #     a.rotate(2)      # => ["c", "d", "a", "b"]
  #     a.rotate(-3)     # => ["b", "c", "d", "a"]
  #
  rotate: (cnt) ->
    new RArray(_arr.rotate(@__native__, cnt))


  # Rotates self in place so that the element at cnt comes first, and returns
  # self. If cnt is negative then it rotates in the opposite direction.
  #
  #     a = R([ "a", "b", "c", "d" ])
  #     a.rotate_bang()      # => ["b", "c", "d", "a"]
  #     a                    # => ["b", "c", "d", "a"]
  #     a.rotate_bang(2)     # => ["d", "a", "b", "c"]
  #     a.rotate_bang(-3)    # => ["a", "b", "c", "d"]
  #
  rotate_bang: (cnt) ->
    return this if cnt is 0 or cnt is 1
    @replace _arr.rotate(@__native__, cnt)


  # Invokes the block passing in successive elements from self, deleting
  # elements for which the block returns a false value. It returns self if
  # changes were made, otherwise it returns nil. See also Array#keep_if
  #
  # If no block is given, an enumerator is returned instead.
  select_bang: (block) ->
    return @to_enum('select_bang') unless block?.call?
    ary = @select(block)
    if ary.__size__() is @__size__() then null else @replace(ary)


  # Invokes the block passing in successive elements from self, returning an
  # array containing those elements for which the block returns a true value
  # (equivalent to Enumerable#select).
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     a = R.w('a b c d e f')
  #     a.select (v) -> v.match /[aeiou]/   #=> ["a", "e"]
  #
  #


  # Returns the first element of self and removes it (shifting all other
  # elements down by one). Returns nil if the array is empty.
  #
  # If a number n is given, returns an array of the first n elements (or less)
  # just like array.slice!(0, n) does.
  #
  #     args = R([ "-m", "-q", "filename" ])
  #     args.shift()     #=> "-m"
  #     args             #=> ["-q", "filename"]
  #
  #     args = R([ "-m", "-q", "filename" ])
  #     args.shift(2)  #=> ["-m", "-q"]
  #     args           #=> ["filename"]
  #
  shift: (n) ->
    throw R.ArgumentError.new() if arguments.length > 1

    if n is undefined
      el = @__native__[0]
      @replace @__native__.slice(1)
      el
    else
      n = RCoerce.to_int_native(n)
      throw R.ArgumentError.new() if n < 0
      ret  = @first(n)
      @replace @__native__.slice(n)
      ret


  # Returns a new array with elements of this array shuffled.
  #
  #     a = [ 1, 2, 3 ]           #=> [1, 2, 3]
  #     a.shuffle()                 #=> [2, 3, 1]
  #
  shuffle: ->
    @dup().tap (ary) -> ary.shuffle_bang()


  # Shuffles elements in self in place. If rng is given, it will be used as
  # the random number generator.
  #
  shuffle_bang: ->
    @replace(_arr.shuffle(@__native__))


  # Length of array
  size: ->
    R(@__native__.length)


  # Length of array as literal
  __size__: ->
    @__native__.length


  # Element Reference—Returns the element at index, or returns a subarray
  # starting at start and continuing for length elements, or returns a
  # subarray specified by range. Negative indices count backward from the end
  # of the array (-1 is the last element). Returns null if the index (or
  # starting index) are out of range.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.slice(2) +  a[0] + a[1]    #=> "cab"
  #     a.slice(6)                   #=> null
  #     a.slice(1, 2)                #=> [ "b", "c" ]
  #     a.slice(1..3)                #=> [ "b", "c", "d" ]
  #     a.slice(4..7)                #=> [ "e" ]
  #     a.slice(6..10)               #=> null
  #     a.slice(-3, 3)               #=> [ "c", "d", "e" ]
  #     # special cases
  #     a.slice(5)                   #=> null
  #     a.slice(5, 1)                #=> []
  #     a.slice(5..10)               #=> []
  #
  slice: (idx, length) ->
    throw new R.TypeError.new() if idx is null

    val = _arr.slice(@__native__, idx, length)
    if val is null
      null
    else if idx?.is_range?
      new RArray(val)
    else if length is undefined
      val
    else
      new RArray(val)


  # Deletes the element(s) given by an index (optionally with a length) or by
  # a range. Returns the deleted object (or objects), or null if the index is
  # out of range.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.slice_bang(1)     # => "b"
  #     a                   # => ["a", "c"]
  #     a.slice_bang(-1)    # => "c"
  #     a                   # => ["a"]
  #     a.slice_bang(100)   # => null
  #     a                   # => ["a"]
  #
  slice_bang: (idx, length) ->
    throw new R.TypeError.new() if idx is null

    ary  = null
    size = @__size__()

    if idx.is_range?
      range = idx
      ary   = @slice(range)
      rng_start = RCoerce.to_int_native(range.begin())
      rng_end   = RCoerce.to_int_native(range.end()  )
      rng_start = rng_start + size if rng_start < 0

      if rng_end < 0
        rng_end = rng_end + size
      else if rng_end >= size
        rng_end >= size

      rng_length = rng_end - rng_start
      rng_length = rng_length + 1 unless range.exclude_end()

      # possible bug? in rubinius rng_end.lteq(size) is rng_end < @total
      if rng_start < size && rng_start >= 0 && rng_end <= size && rng_end >= 0 && rng_length > 0
        @__delete_range(rng_start, rng_length)

    else if length isnt undefined
      idx    = RCoerce.to_int_native(idx)
      length = RCoerce.to_int_native(length)

      return null if idx > size
      return new R.Array([]) if length is 0

      ary = @slice(idx, length)
      @__delete_range(idx, length)

    else
      idx = RCoerce.to_int_native(idx)
      ary = @delete_at(idx)

    ary

  # @private
  __delete_range: (start, length) ->
    size = @__size__()
    return null if start > size or start < 0

    if size < (start + length)
      new_ary = new R.Array([])
    else
      new_ary = @slice(0, start).concat(@slice(start + length, size) || [])

    @replace(new_ary) unless new_ary.__size__() is @__size__()


  # Sorts self. Comparisons for the sort will be done using the <=> operator
  # or using an optional code block. The block implements a comparison between
  # a and b, returning -1, 0, or +1.
  #
  # @see Enumerable#sort_by
  # @note Suboptimally implemented, by replacing it with Enumerable#sort().to_native()
  #
  sort_bang: (block) ->
    @replace @sort(block)


  # Sorts self in place using a set of keys generated by mapping the values in
  # self through the given block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  sort_by_bang: (block) ->
    return @to_enum('sort_by_bang') unless block?.call?
    @replace @sort_by(block)


  # Assumes that self is an array of arrays and transposes the rows and columns.
  #
  # @example
  #     a = R([[1,2], [3,4], [5,6]])
  #     a.transpose()   # => [[1, 3, 5], [2, 4, 6]]
  #
  transpose: ->
    new RArray(_arr.transpose(@__native__))


  # Returns a new array by removing duplicate values in self.
  #
  # @example
  #     a = R([ "a", "a", "b", "b", "c" ])
  #     a.uniq()   # => ["a", "b", "c"]
  #     # Not yet implemented:
  #     c = R([ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ])
  #     c.uniq (s) -> s[/^\w+/]  #=> [ "a:def", "b:abc", "c:jkl" ]
  #
  # @note Not yet correctly implemented. should use #eql on objects, but uses @include().
  #
  uniq: () ->
    arr = new R.Array([])
    @each (el) ->
      arr.push(el) unless arr.include(el)
    arr


  # Removes duplicate elements from self. Returns null if no changes are made
  # (that is, no duplicates are found).
  #
  # @example
  #     a = R([ "a", "a", "b", "b", "c" ])
  #     a.uniq!   # => ["a", "b", "c"]
  #     b = R([ "a", "b", "c" ])
  #     b.uniq!   # => null
  #     # Not yet implemented:
  #     c = R([ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ])
  #     c.uniq (s) -> s[/^\w+/]  #=> [ "a:def", "b:abc", "c:jkl" ]
  #
  # @note Not yet correctly implemented. should use #eql on objects, but uses @include().
  #
  uniq_bang: (block) ->
    ary = @uniq()
    if ary.__size__() is @__size__() then null else @replace(ary)


  # Prepends objects to the front of self, moving other elements upwards.
  #
  # @example
  #     a = R([ "b", "c", "d"])
  #     a.unshift("a")   #=> ["a", "b", "c", "d"]
  #     a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]
  #
  unshift: ->
    @replace(__call(_arr.unshift, @__native__, arguments))


  # Set Union—Returns a new array by joining this array with other_ary,
  # removing duplicates.
  #
  #     R([ "a", "b", "c" ]).union [ "c", "d", "a" ]
  #       #=> [ "a", "b", "c", "d" ]
  #
  union: (other) ->
    new RArray(_arr.union(@__native__, other))


  to_a: ->
    @dup()


  # find a better way for this.
  to_enum: (iter = "each", args...) ->
    new R.Enumerator(this, iter, args)


  to_ary: () -> this


  # Returns an array containing the elements in self corresponding to the
  # given selector(s). The selectors may be either integer indices or ranges.
  # See also Array#select.
  #
  # @example
  #     a = R(['a', 'b', 'c', 'd', 'e', 'f'])
  #     a.values_at(1, 3, 5)
  #     a.values_at(1, 3, 5, 7)
  #     a.values_at(-1, -3, -5, -7)
  #     a.values_at(1..3, 2...5)
  #
  # @todo not working with ranges
  #
  values_at: (args...) ->
    new RArray(__call(_arr.values_at, @__native__, args))


  # ---- Aliases --------------------------------------------------------------

  @__add_default_aliases__(@prototype)

  # @alias collect_bang
  map_bang:     @prototype.collect_bang

  # @alias find_index
  index:        @prototype.find_index

  # @alias each
  each_for:     @prototype.each


  # @alias union
  '|':          @prototype.union

  to_s:         @prototype.inspect

  # @alias &
  intersection: @prototype['&']


  deleteAt:     @prototype.delete_at
  deleteIf:     @prototype.delete_if
  dropWhile:    @prototype.drop_while
  eachIndex:    @prototype.each_index
  equalValue:   @prototype.equal_value
  findIndex:    @prototype.find_index
  intersection: @prototype.intersection
  keepIf:       @prototype.keep_if
  reverse_each: @prototype.reverse_each
  sortBy:       @prototype.sort_by
  takeWhile:    @prototype.take_while
  toA:          @prototype.to_a
  toAry:        @prototype.to_ary
  toS:          @prototype.to_s
  tryConvert:   @prototype.try_convert
  valuesAt:     @prototype.values_at



RArray = R.Array = RubyJS.Array

